package com.niit.TaskService.controller;

import com.niit.TaskService.domain.DeletedTask;
import com.niit.TaskService.domain.Task;
import com.niit.TaskService.exception.BoardNotFoundException;
import com.niit.TaskService.proxy.BoardClient;
import com.niit.TaskService.proxy.UserClient;
import com.niit.TaskService.service.TaskService;
import com.niit.TaskService.exception.UserNotFoundException;
import com.niit.TaskService.exception.TaskNotFoundException;
import com.niit.TaskService.exception.TaskAlreadyExistException;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.ArrayList;
import java.util.List;

@RestController
@RequestMapping("/task")
@CrossOrigin(origins = "http://localhost:4200")// Allow requests from any origin
public class TaskController {

    private final TaskService taskService;
    private final UserClient userClient;
    private final BoardClient boardClient;
    private final Logger logger = LoggerFactory.getLogger(TaskController.class);

    public TaskController(TaskService taskService, UserClient userClient, BoardClient boardClient) {
        this.taskService = taskService;
        this.userClient = userClient;
        this.boardClient = boardClient;
    }

    @PostMapping("/create")
    public ResponseEntity<?> create(@RequestBody Task task) {
        try {
            boolean assigneeExists = userClient.checkUserExistsByEmail(task.getAssigneeEmail());
            if (!assigneeExists) {
                return ResponseEntity.status(HttpStatus.BAD_REQUEST).body("Assignee email does not exist in the user database");
            }
            // Autogenerated User ID fetched from the user service
            String userId = userClient.getUserById(task.getUserId()).getUserId();

            // Autogenerated Board ID fetched from the board service
            String boardId = boardClient.getBoardById(task.getBoardId()).getBody().getBoardId();

            // Initialize lists for todo, inprogress, completed, and archived
            task.setTodo(new ArrayList<>());
            task.setInProgress(new ArrayList<>());
            task.setCompleted(new ArrayList<>());
            task.setArchived(new ArrayList<>()); // Initialize archived list

            // Add the task to the appropriate list based on the provided initial state
            switch (task.getInitialState().toLowerCase()) {
                case "inprogress":
                    task.getInProgress().add(task.getTaskId());
                    break;
                case "completed":
                    task.getCompleted().add(task.getTaskId());
                    break;
                case "archived": // Add to archived list if the initial state is "archived"
                    task.getArchived().add(task.getTaskId());
                    break;
                default: // Default to "todo" if no initial state is provided or if it's invalid
                    task.getTodo().add(task.getTaskId());
            }

            // Creating the task with the fetched board ID, user ID, and provided status
            Task createdTask = taskService.create(task, userId, boardId);

            // Returning the created task in the response
            return ResponseEntity.ok(createdTask);
        } catch (TaskAlreadyExistException ex) {
            return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(ex.getMessage());
        } catch (UserNotFoundException | TaskNotFoundException | BoardNotFoundException ex) {
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(ex.getMessage());
        } catch (Exception ex) {
            // Log the exception for debugging purposes
            logger.error("An error occurred while creating the task", ex);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body("An error occurred while creating the task");
        }
    }



    @GetMapping
    public List<Task> getAll() {
        return taskService.getAll();
    }

    @GetMapping("/{taskId}")
    public ResponseEntity<?> getOne(@PathVariable String taskId) {
        try {
            Task task = taskService.getOne(taskId);
            return ResponseEntity.ok(task);
        } catch (TaskNotFoundException ex) {
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(ex.getMessage());
        } catch (Exception ex) {
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body("An error occurred while retrieving the task");
        }
    }

    @GetMapping("/board/{boardId}")
    public ResponseEntity<List<Task>> getTasksOfBoard(@PathVariable String boardId) {
        List<Task> tasks = taskService.getTasksOfBoard(boardId);
        return ResponseEntity.ok(tasks);
    }
    @PutMapping("/{taskId}/move")
    public ResponseEntity<?> moveTask(@PathVariable String taskId, @RequestParam String status) {
        try {
            // Fetch the task by taskId
            Task task = taskService.getOne(taskId);

            // Remove the task from its current state list
            taskService.removeTaskFromCurrentStateList(task);

            // Update the task's initial state based on the provided status
            switch (status.toLowerCase()) {
                case "inprogress":
                    task.setInitialState("inprogress");
                    task.getInProgress().add(taskId); // Add taskId to inProgress list
                    break;
                case "completed":
                    task.setInitialState("completed");
                    task.getCompleted().add(taskId); // Add taskId to completed list
                    break;
                case "archived":
                    task.setInitialState("archived");
                    task.getArchived().add(taskId); // Add taskId to archived list
                    break;
                default:
                    task.setInitialState("todo"); // Default to "todo" if status is not recognized
                    task.getTodo().add(taskId); // Add taskId to todo list
            }

            // Update the task in the database
            Task updatedTask = taskService.update(task);

            // Return the updated task in the response
            return ResponseEntity.ok(updatedTask);
        } catch (TaskNotFoundException ex) {
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(ex.getMessage());
        } catch (Exception ex) {
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body("An error occurred while updating the task");
        }
    }




    @DeleteMapping("/{taskId}")
    public ResponseEntity<?> deleteTask(@PathVariable String taskId) {
        try {
            taskService.delete(taskId);
            return ResponseEntity.ok("Task deleted successfully");
        } catch (TaskNotFoundException ex) {
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(ex.getMessage());
        } catch (Exception ex) {
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body("An error occurred while deleting the task");
        }
    }




    @GetMapping("/deletedtask/{userId}")
    public ResponseEntity<List<DeletedTask>> getDeletedTasksByUserId(@PathVariable String userId) {
        try {
            List<DeletedTask> deletedTasks = taskService.getAllDeletedTasksByUserId(userId);
            return ResponseEntity.ok(deletedTasks);
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(null); // Or handle the error as needed
        }
    }

    @PutMapping("/{taskId}")
    public ResponseEntity<?> editTask(@PathVariable String taskId, @RequestBody Task updatedTask) {
        try {
            // Fetch the task by taskId
            Task existingTask = taskService.getOne(taskId);

            // Update the task details
            existingTask.setTaskName(updatedTask.getTaskName());
            existingTask.setBoardId(updatedTask.getBoardId());
            existingTask.setTaskDescription(updatedTask.getTaskDescription());
            existingTask.setTaskDeadline(updatedTask.getTaskDeadline());

            // Check if the assignee email exists in the user database
            boolean assigneeExists = userClient.checkUserExistsByEmail(updatedTask.getAssigneeEmail());
            if (!assigneeExists) {
                return ResponseEntity.status(HttpStatus.BAD_REQUEST).body("EmailID you provided is not registered");
            }

            existingTask.setAssigneeEmail(updatedTask.getAssigneeEmail()); // Set assignee email
            existingTask.setInitialState(updatedTask.getInitialState());

            // Save the updated task
            Task editedTask = taskService.update(existingTask);

            // Return the updated task in the response
            return ResponseEntity.ok(editedTask);
        } catch (TaskNotFoundException ex) {
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(ex.getMessage());
        } catch (Exception ex) {
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body("An error occurred while editing the task");
        }
    }


    @GetMapping("/assignee/{assigneeEmail}")
    public ResponseEntity<List<Task>> getTasksByAssigneeEmail(@PathVariable String assigneeEmail) {
        List<Task> tasks = taskService.getTasksByAssigneeEmail(assigneeEmail);
        return new ResponseEntity<>(tasks, HttpStatus.OK);
    }
    @PostMapping("/restore/{taskId}")
    public ResponseEntity<?> restoreTask(@PathVariable String taskId) {
        try {
            taskService.restoreTask(taskId);
            return ResponseEntity.ok("Task restored successfully");
        } catch (TaskNotFoundException ex) {
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(ex.getMessage());
        } catch (Exception ex) {
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body("An error occurred while restoring the task");
        }
    }

}